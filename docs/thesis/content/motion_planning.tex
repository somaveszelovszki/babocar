\chapter{Motion planning}

\section{Existing local planner algorithms}
\label{chap:existing_local_planner_algorithms}
After building a map of the static and dynamic objects surrounding the vehicle, the next step is motion planning, which consists of two sub-tasks - global trajectory planning and local obstacle avoidance. As a result of global planning, a trajectory is created that - without taking the moving obstacles into consideration - leads the car to the target configuration, without making it collide with any static objects in the way. Local obstacle avoidance takes this trajectory as its input, and updates the car's actuators (acceleration and steering) to follow this trajectory, while also preventing collisions with dynamic objects.
As a part of my diploma project, I implemented the latter, a local obstacle avoidance algorithm, that relies on the previously created static and dynamic maps, and gets its input trajectory from a global planner node\footnote{Implementing a global motion planner was not part of my diploma project, but is considered a necessary condition for the local planner to work properly.}. According to \cite{DynamicMotionPlanningSurvey}, there exists a wide range of local planner algorithms, and they can easily be grouped by their complexity:

\begin{itemize}
  \item Velocity-based methods, most of the times combined with the dynamic window approach
  \item Predictive and probability-based methods
  \item Complex methods based on visual detection and AI
  \item Other methods
\end{itemize}

Out of these methods, velocity-based algorithms are by far the most popular, due to their being relatively easy to comprehend and implement and because of their low hardware requirements. As the mapping node and the local planner that I designed need to run on a processor with limited resources, I also chose a velocity-based obstacle avoidance method, using velocity obstacles, with dynamic windowing.

\section{Method}

The planner algorithm I implemented uses velocity obstacles to determine which configurations of the car are safe. Velocity obstacle methods (descibed in \cite{VelocityForbiddenMap} and in \citep{VelocityObstacles}) are based on the following statement: \textit{Assuming a given a given vehicle configuration (position, orientation, speed and wheel angle), the time until collision with a given static or dynamic object in the map can be calculated.} Therefore, velocity obstacle-based methods calculate this collision time for all surrounding objects and for all vehicle velocities. thus creating a velocity obstacle map, or forbidden velocity map (also referred to as dynamic velocity space in \cite{DynamicMotionPlanningSurvey}). Using the dynamic window approach is advised in this step,as it filters out non-reachable velocities before collision-time calculations, thus decreasing the execution time of the algorithm.
Given this velocity obstacle map, the algorithm has a basic knowledge of the reachable velocities and their level of safety. These safety levels provide a good starting point for further calculations, trajectory and collision estimations. My algorithm converts the forbidden velocity map's collision times to safety factors, but also takes the destination point's position and the target speed into consideration when selecting the next actuator outputs.
The next graph shows all the sub-tasks of the local trajectory planner algorithm.

\tikzset{
     base_node/.style = {rectangle, rounded corners, draw=black,
                         minimum width=4.5cm, minimum height=1cm,
                         text centered, font=\sffamily},
  inout_node/.style        = {base_node, fill=blue!30},
  update_node/.style   = {base_node, fill=orange!15},
  dynamic_node/.style  = {base_node, fill=red!30},
  static_node/.style   = {base_node, fill=yellow!30},
  velo_obs_node/.style = {base_node, fill=green!30},
  decoration={brace},
  tuborg/.style={decorate},
  tubnode_left/.style={midway, left=2pt},
  tubnode_right/.style={midway, right=2pt}
}

\begin{figure}[!ht]
    \begin{tikzpicture}[
            node distance=1.5cm,
            every node/.style={fill=white, font=\sffamily}, align=center]
        % Input nodes
        \node (static_map)      [inout_node, yshift=-3cm]                              {Static map};
        \node (trajectory)      [inout_node, xshift=5.2cm]                             {Input trajectory};
        \node (dynamic_objects) [inout_node, xshift=10.4cm, yshift=-1.5cm]             {Dynamic objects};
        % Update nodes
        \node (find_dest)       [update_node, below of=trajectory]                     {Find destination};
        \node (calc_target_act) [update_node, below of=find_dest]                      {Calculate target actuation};
        \node (update_window)   [update_node, below of=calc_target_act]                {Update dynamic window};
		% Static nodes
        \node (static_filter)   [static_node, below of=static_map]                     {Filter};
        \node (static_calc_col) [static_node, below of=static_filter]                  {Calculate collision times};
		% Dynamic nodes
        \node (dynamic_filter)  [dynamic_node, below of=dynamic_objects]               {Filter};
        \node (dynamic_traj)    [dynamic_node, below of=dynamic_filter]                {Calculate trajectories};
        \node (dyn_calc_col)    [dynamic_node, below of=dynamic_traj]                  {Calculate collision times};
        % Velocity obstacle nodes
        \node (fitness_factors) [velo_obs_node, below of=update_window, yshift=-1.5cm] {Update fitness factors};
        \node (get_best_act)    [velo_obs_node, below of=fitness_factors]              {Get best actuation};
        \node (acker_drive)     [inout_node, below of=get_best_act]                    {Publish Ackermann drive};
        % Static connections
        \draw[->]      (static_map) -- (static_filter);
        \draw[->]   (static_filter) -- (static_calc_col);
        % Update connections
        \draw[->]      (trajectory) -- (find_dest);
        \draw[->]       (find_dest) -- (calc_target_act);
        \draw[->] (calc_target_act) -- (update_window);
        \draw[->]   (update_window) -- (static_calc_col);
        \draw[->]   (update_window) -- (dyn_calc_col);
        % Dynamic connections
        \draw[->] (dynamic_objects) -- (dynamic_filter);
        \draw[->]  (dynamic_filter) -- (dynamic_traj);
        \draw[->]    (dynamic_traj) -- (dyn_calc_col);
        % Velocity obstacle connections
        \draw[->] (static_calc_col) -- (fitness_factors);
        \draw[->]    (dyn_calc_col) -- (fitness_factors);
        \draw[->] (fitness_factors) -- (get_best_act);
        \draw[->]    (get_best_act) -- (acker_drive);
    \end{tikzpicture}
    \caption{Motion planning method}
    \label{motion_planning_method}
\end{figure}

The diagram consists of 4 subgraphs - these are also marked on the diagram with different colors. The orange subgraph describes the environment-independent sub-tasks of the algorithm - finding the next destination point, updating the target actuation and the dynamic window. The yellow one is about the method of reducing the size of the static map by filtering out those points that are not needed for the trajectory planning. The red side subgraph shows that for dynamic objects, trajectory calculation is also necessary besides filtering. And the last one (populating the bottom area of the graph, marked with green colour) contains the main planning logic. The next sections are going to explain these subgraphs in detail.

\section{Target actuation and dynamic window}
\label{chap:target_actuation_and_dynamic_window}
In every loop (at each new incoming map data), the target actuation and the dynamic window are updated. The target actuation describes the desired speed and steering wheel angle for the next step, therefore the desired linear and angular speed vectors. The dynamic window is independent from the target actuation, but depends on the current actuation. It contains a set of speeds and wheel angles that are reachable by the car within the next step. The width and height of the window (the maximum speed and wheel angle change in one step) are defined by the mechanical characteristics of the car.
So basically, the aim of this subtask is to provide the algorithm a target actuation, and a set of reachable actuations.
When I implemented the target actuation update mechanism, that leads the car according to the input trajectory, I had several options to choose from. The first option was to split the trajectory into line-segments, and implement and tune a steering angle controller (e.g. a PD controller) to follow this line. I dropped this idea to prevent the re-tuning that would have been needed for each target vehicles (simulation, real-life test vehicles). Another option was the 'invisible string' the 'dog bone' method, where a target destination point is always in front of the car, and the car is always trying to reach this point, as if the point was pulling it by a string. The target actuation's wheel angle defines a trajectory curve, that goes through the destination point. If the destination point is always on the trajectory, and in front of car (within the right distance range), the car is goint to follow the trajectory. I chose the latter (the 'invisible string') method.

\subsection{Finding the next destination point}
This method requires a destination point in each iteration. This point is preferably on the trajectory, in front of the car, 'pulling' the car to the right direction. The destination point search start with finding the point in the trajectory nearest to the car's current position. The destination point needs to be in front of the car, but its distance from the car (which is nearly equal to its distance from the previously found nearest point) is not trivial (see figure \ref{dest_point_update}).

\begin{figure}[!ht]
    \centering
    \includegraphics[height=48mm]{figures/raw/dest_point_update.png}
    \caption{Updating the destination point}
    \label{dest_point_update}
\end{figure}

Choosing a too near destination will result in the car starting to oscillate around the target trajectory with an increasing amplitude, until a point where the angular difference between the car and the trajectory will be too large for the car to find the path again. This situation is displayed in figure \ref{traj_oscillation}.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=65mm]{figures/raw/traj_oscillation.png}
    \caption{Oscillation around the target trajectory}
    \label{traj_oscillation}
\end{figure}

However, the destination point must not be chosen too far, either, because it straightens the curves of the trajectory, rounds its sharp edges, and adds an offset to the long circular sections. Figure \ref{traj_rounding} demonstrates these effects. The effect shown on the left side might even be advantageous, but the righ-hand side effect is certainly not.

\begin{figure}[!ht]
    \centering
    \subfloat[Rounding sharp peaks]
    {
        \includegraphics[height=48mm]{figures/raw/traj_round_sharp_peak.png}
        \label{traj_round_sharp_peak}
    }
    \subfloat[Rounding curves]
    {
    	\includegraphics[height=48mm]{figures/raw/traj_round_curve.png}
        \label{traj_round_curve}
    }
    \caption{Trajectory rounding}
    \label{traj_rounding}
\end{figure}

After empirical testing, the optimal distance of the destination point and the nearest trajectory point (marked with yellow and black dots in figure \ref{dest_point_update}) proved to be around 4 times the distance between the car's front and rear axles. Note, that this value largely depends on the dynamic window's maximum angular velocity limit and the car's mechanical characteristics (e.g. using a faster steering servo or a 4-wheel steering car would reduce the optimal distance).

\subsection{Calculating the target actuation}
After the destination point has been selected, the next step is to calculate the target actuation - the speed and steering angle pair that would lead the car to the destination point. First, the target wheel angle is calculated using linear algebra (see figure \ref{calc_steering_angle}). The target speed calculation is based on two factors. The first is the target speed limit, which we expect the car to keep, given no extraordinary circumstances. This should be set to a safe speed that the car can keep up during its travel. The actual target speed will never exceed this limit. But the target steering angle may require this target speed to be lower. Trivially, the car can manage to reach higher speeds safely when going straight, than when in a sharp bend.

\begin{figure}[!ht]
    \centering
    \includegraphics[height=48mm]{figures/raw/calc_steering_angle.png}
    \caption{Calculating the target steering angle}
    \label{calc_steering_angle}
\end{figure}

\subsection{Updating the dynamic window}

\section{Target actuation}
\label{chap:target_actuation}

\section{Static velocity obstacle map}
\label{chap:static_velocity_obstacle_map}
Static points in the map populate a very large percent of the car's surroundings, so handling them efficiently can boost up the algorithms runtime performance. Therefore, they are not joined with the dynamic points, but filtered separately, and the collision times are calculated in a way that is optimized for non-moving objects to gain performance.

\subsection{Filtering static points}
Separating the static points from the dynamic objects has both advantages and disadvantages for local motion planning. The most important advantage is that the collision check with static points is much simpler and faster than with dynamic obstacles. A great disadvantage, however, is that the static map contains lots of points, and running a collision check on all of them would cause the algorithm to be unacceptably slow. To prevent this undesired behaviour, a preparatory filter is applied to the map, removing those points from the map, that are too far from the car's current position to be worth keeping. Depending on the environment's characteristics, this step may reduce the runtime of the static collision times drastically - even to zero, if all the static points are far from the car (e.g. in a large room).

\begin{figure}[!ht]
    \centering
    \includegraphics[height=110mm]{figures/raw/rviz_2_near_static_objects_filter.png}
    \caption{Static filtering}
    \label{rviz_2_near_static_objects_filter}
\end{figure}

Figure \ref{rviz_2_near_static_objects_filter} shows that the mapped environment of the car is a much larger territory than what the motion planning algorithm needs to check for collisions. The circle marks the area that is kept after the filtering. In this example, this area contains the two square-shaped obstacles, all the other points in the static map are thrown.

\subsection{Static collision times}
Collision times
Due to the fact that the number of static points is usually high compared to the dynamic points, the collision times are calculated separately, so that the calculation can be optimized for static objects. Collision check with static objects is executed the following way.
The 

\section{Dynamic velocity obstacle map}
\label{chap:dynamic_velocity_obstacle_map}

\subsection{Filtering dynamic objects}

\subsection{Trajectory calculation}

\subsection{Dynamic collision times}

\section{Velocity obstacle map evaluation}
\label{chap:velocity_obstacle_map_evaluation}

\subsection{Fitness factors}

\subsection{Best actuation}

\subsection{Publishing Ackermann driving control}
