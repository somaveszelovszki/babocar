\chapter{Test results}
\label{chap:test_results}

Now that the algorithms have been written about in detail, let me explain how I tested the nodes both in simulator and in real life.

\section{Mapping results}
The aim of the mapping node was to find the moving objects in the environment, based on LIDAR scans, and to separate them from the static parts of the map. The algorithm converted the LIDAR measurements into absolute map points, than created a differential grid - basically a map, with the high values not marking objects like a regular map, but marking movements. The algorithm found the possible dynamic point candidates based on this grid. After the candidates have been selected, the algorithm created groups among the measured points, based on the positions. Relying on these groups being valid, and the assumption that points in the same group must be still or moving in the same direction, speed vectors were calculated for the groups. The groups with speed larger than a minimum value (which may be caused by measurement noise) became the moving objects, and the points inside these groups were marked dynamic. Every other measurement was treated non-moving, and therefore placed in the static map. The static map building is as straightforward as it can be - every static measurement creates a free ray in the map, starting from the position of the LIDAR and ending at the measured point.

The results of the mapping and the separation of static and dynamic points are presented by an example with a valid use-case. The scenario is the following. The car is standing in a closed room, the distance from the walls are smaller than the LIDAR's range. There is one other object in the room, in the simulation, this is a ball, its size similar to the car's. The ball is standing in one place at first, but after a while, it start moving in a straight path with constant speed. Finally, the car starts moving as well - first in a straight path, then turning.

\ref{mapping_demo_start} presents the initial situation of the demonstration. The left image shows the simulation - the car is standing in the middle of the room, the object in the top left corner is not moving yet. On the right image, the created static map is visible. The number of unknown (grey) grid points is large at this state of the simulation, it will dramatically decrease once the car starts moving. This effect is caused by the LIDAR's finite angular resolution and ray characteristics. The black grid points represent statically occupied positions. All the walls are marked static, and the ball as well.

\begin{figure}[!ht]
    \centering
    \subfloat[Gazebo simulation]
    {
        \includegraphics[height=70mm]{figures/raw/mapping_demo/gazebo_start.png}
        \label{mapping_demo_gazebo_start}
    }
    \subfloat[rviz visualization]
    {
    \includegraphics[height=70mm]{figures/raw/mapping_demo/rviz_start.png}
        \label{mapping_demo_rviz_start}
    }
    \caption{Initial state - ball is still}
    \label{mapping_demo_start}
\end{figure}

Once the ball starts moving (\ref{mapping_demo_ball_moving}), it stops being marked as static, but is handled as a moving object. The static block at the top left corner has been removed, and the ball is displayed using the dynamic visualization toolset - a sphere and an arrow, representing the ball's area and speed vector.

\begin{figure}[!ht]
    \centering
    \subfloat[Gazebo simulation]
    {
        \includegraphics[height=70mm]{figures/raw/mapping_demo/gazebo_ball_moving.png}
        \label{mapping_demo_gazebo_ball_moving}
    }
    \subfloat[rviz visualization]
    {
    \includegraphics[height=70mm]{figures/raw/mapping_demo/rviz_ball_moving.png}
        \label{mapping_demo_rviz_ball_moving}
    }
    \caption{The ball is moving}
    \label{mapping_demo_ball_moving}
\end{figure}

When the car starts moving, the map immediately starts to clear out. If we compare \ref{mapping_demo_ball_moving} and \ref{mapping_demo_car_moving}, it is clear that the latter contains less unknown grid points.

\begin{figure}[!ht]
    \centering
    \subfloat[Gazebo simulation]
    {
        \includegraphics[height=70mm]{figures/raw/mapping_demo/gazebo_car_moving.png}
        \label{mapping_demo_gazebo_car_moving}
    }
    \subfloat[rviz visualization]
    {
    \includegraphics[height=70mm]{figures/raw/mapping_demo/rviz_car_moving.png}
        \label{mapping_demo_rviz_car_moving}
    }
    \caption{The car is moving}
    \label{mapping_demo_car_moving}
\end{figure}

Due to the map implementation being very simple, and updating each map point without handling its history, the mapping node can only be used with certain limitations regarding obstacle speed and the car's angular velocity. But the main task for the mapping algorithm was not to create a static map with the best possible quality, but to separate the static points from the dynamic objects.

\section{Motion planning results}
The task of the motion planning node was to calculate and publish actuations based on the static and dynamic maps provided by the mapping node, that lead the car towards the destination, following the required trajectory, without any collisions. The algorithm first filters the static and dynamic input maps to decrease the number of environment points. Then it calculates trajectories for the dynamic obstacles. Independently from the maps, it sets the target actuation according to the target trajectory or an external control command, and also updates the dynamic window, based on the current actuation. When all these steps are finished, it calculates the collision times for all the actuations in the dynamic window and all objects in the car's environment, and builds the velocity obstacle map. Using this map and the target actuation, fitness factors are calculated for all available actuations. Summarizing and evaluating these factors, the best possible actuation is determined. This actuation is then published to the actuator nodes.

As the motion planning examples also demonstrate the map building implicitly, I recorded several measurements of different kinds of scenarios, and I selected a set of them that represent the algorithms advantages and deficiencies. Most of the scenarios I tested in simulation.

As a 0th step, I tested if the algorithm follows a straight, then a curved trajectory with no obstacles in the way. These tests were needed to check if actuation handling and the target position update mechanism work as expected. After these features were tested successfully, the testing procedure could move forward to moving objects in the trajectories.

The first example is still a quite simple one. The car is given a straight trajectory, but there is a static obstacle in its way. The expected behaviour is to bypass the object while staying as close to the trajectory as possible, and when the car has moved past the obstacle, it should keep to the trajectory again.

The simulation images always display the Gazebo simulation on the right and the rviz visualization on the left. Let me briefly summarize how the objects are displayed in rviz. The car has red colour, the target trajectory is marked by the green line. The LIDAR scan consists of the red dots and the map points are either white (free), grey (unknown) or black (occupied). Therefore, static objects appear as black masses in the map. Each dynamic object is marked with a blue circle representing its position and size, and a green arrow for its speed vector.

\begin{figure}[!ht]
	\centering
	\subfloat[]
	{
		\includegraphics[width=\textwidth]{figures/raw/local_planner_test_straight_traj_static_obj_1.png}
		\label{local_planner_test_straight_traj_static_obj_1}
	}

	\subfloat[]
	{
		\includegraphics[width=\textwidth]{figures/raw/local_planner_test_straight_traj_static_obj_2.png}
		\label{local_planner_test_straight_traj_static_obj_2}
	}

	\subfloat[]
	{
		\includegraphics[width=\textwidth]{figures/raw/local_planner_test_straight_traj_static_obj_3.png}
		\label{local_planner_test_straight_traj_static_obj_3}
	}

	\subfloat[]
	{
		\includegraphics[width=\textwidth]{figures/raw/local_planner_test_straight_traj_static_obj_4.png}
		\label{local_planner_test_straight_traj_static_obj_4}
	}

	\caption{Straight trajectory, static obstacle}
	\label{local_planner_test_straight_traj_static_obj}
\end{figure}

As the images \ref{local_planner_test_straight_traj_static_obj_1}-\ref{local_planner_test_straight_traj_static_obj_4} show, the car successfully avoids the object and then keeps to the trajectory again.

The second example is similar to the first one, but has one major difference: the object to avoid is not static but is moving opposite the car, with a speed nearly equal to the car's.

\begin{figure}[!ht]
	\centering
	\subfloat[]
	{
		\includegraphics[width=\textwidth]{figures/raw/local_planner_test_straight_traj_dyn_obj_1.png}
		\label{local_planner_test_straight_traj_dyn_obj_1}
	}

	\subfloat[]
	{
		\includegraphics[width=\textwidth]{figures/raw/local_planner_test_straight_traj_dyn_obj_2.png}
		\label{local_planner_test_straight_traj_dyn_obj_2}
	}

	\subfloat[]
	{
		\includegraphics[width=\textwidth]{figures/raw/local_planner_test_straight_traj_dyn_obj_3.png}
		\label{local_planner_test_straight_traj_dyn_obj_3}
	}

	\subfloat[]
	{
		\includegraphics[width=\textwidth]{figures/raw/local_planner_test_straight_traj_dyn_obj_4.png}
		\label{local_planner_test_straight_traj_dyn_obj_4}
	}

	\caption{Straight trajectory, dynamic obstacle}
	\label{local_planner_test_straight_traj_dyn_obj}
\end{figure}

Figures \ref{local_planner_test_straight_traj_dyn_obj_1}-\ref{local_planner_test_straight_traj_dyn_obj_4} represent the scenario. Comparing images \ref{local_planner_test_straight_traj_static_obj_2} and \ref{local_planner_test_straight_traj_dyn_obj_2}, it clearly shows that in the latter case (when the object is moving opposite the car), the car starts the obstacle avoidance movement a lot earlier. That is because the object is successfully detected as dynamic (marked by a blue circle and a green speed vector in the rviz visualization).

\begin{figure}[!ht]
	\centering
	\subfloat[]
	{
		\includegraphics[width=\textwidth]{figures/raw/local_planner_test_straight_traj_faster_obj_from_behind_1.png}
		\label{local_planner_test_straight_traj_faster_obj_from_behind_1}
	}

	\subfloat[]
	{
		\includegraphics[width=\textwidth]{figures/raw/local_planner_test_straight_traj_faster_obj_from_behind_2.png}
		\label{local_planner_test_straight_traj_faster_obj_from_behind_2}
	}

	\subfloat[]
	{
		\includegraphics[width=\textwidth]{figures/raw/local_planner_test_straight_traj_faster_obj_from_behind_3.png}
		\label{local_planner_test_straight_traj_faster_obj_from_behind_3}
	}

	\subfloat[]
	{
		\includegraphics[width=\textwidth]{figures/raw/local_planner_test_straight_traj_faster_obj_from_behind_4.png}
		\label{local_planner_test_straight_traj_faster_obj_from_behind_4}
	}

	\caption{Straight trajectory, faster obstacle from behind}
	\label{local_planner_test_straight_traj_faster_obj_from_behind}
\end{figure}

The scenario represented in figures \ref{local_planner_test_straight_traj_faster_obj_from_behind_1}-\ref{local_planner_test_straight_traj_faster_obj_from_behind_4} is different from the previous ones in a way. This is the first situation where an actuation that stops the car would cause a collision. That is because in this scenario, a faster object is approaching the vehicle from behind. To prevent a crash, the car must deviate from its original trajectory in order to let the faster obstacle pass by. Then it can continue on its original route again. Personally, this is my favourite scenario of all.

The last example I am going to present points out a deficiency of the algorithm. Which is that it does not see the whole path, it only thinks forward for the next couple of meters\footnote{This distance (the length of the virtual string pulling the car towards the destination) is configurable, but optimally is around 4 times the distance between the car's front and rear axles.}.

\begin{figure}[!ht]
	\centering
	\subfloat[]
	{
		\includegraphics[width=\textwidth]{figures/raw/local_planner_test_curved_traj_2_static_objects_1.png}
		\label{local_planner_test_curved_traj_2_static_objects_1}
	}

	\subfloat[]
	{
		\includegraphics[width=\textwidth]{figures/raw/local_planner_test_curved_traj_2_static_objects_2.png}
		\label{local_planner_test_curved_traj_2_static_objects_2}
	}

	\subfloat[]
	{
		\includegraphics[width=\textwidth]{figures/raw/local_planner_test_curved_traj_2_static_objects_3.png}
		\label{local_planner_test_curved_traj_2_static_objects_3}
	}

	\subfloat[]
	{
		\includegraphics[width=\textwidth]{figures/raw/local_planner_test_curved_traj_2_static_objects_4.png}
		\label{local_planner_test_curved_traj_2_static_objects_4}
	}

	\subfloat[]
	{
		\includegraphics[width=\textwidth]{figures/raw/local_planner_test_curved_traj_2_static_objects_5.png}
		\label{local_planner_test_curved_traj_2_static_objects_5}
	}

	\subfloat[]
	{
		\includegraphics[width=\textwidth]{figures/raw/local_planner_test_curved_traj_2_static_objects_6.png}
		\label{local_planner_test_curved_traj_2_static_objects_6}
	}

	\caption{Curved trajectory, 2 static obstacles}
	\label{local_planner_test_curved_traj_2_static_objects}
\end{figure}