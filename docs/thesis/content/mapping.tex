\chapter{Mapping}

\section{Method}
This chapter decribes the process of building a separate static and a dynamic map (containing non-moving and moving obstacles, respectively) based on radial distance measurements (in this case provided by a LIDAR). Isolating the static and the moving obstacles from each other has its difficulties but also its advantages. First of all, the implemented local track planner calculates safer, more optimized paths if it is informed of both the static and the dynamic obstacles along the path. Secondly, \href{https://en.wikipedia.org/wiki/Simultaneous_localization_and_mapping}{SLAM} (Simultaneous localization and mapping) algorithms work better if the their input contains only static objects in the space, because they build an internal map of the world. Passing detections of moving obstacles to a SLAM algorithm may lead to worse localization quality, as they may ruin this map.

As a first subtask of the mapping project, I checked if any implementation is avaiable already, that can handle dynamic objects. One possible candidate was \href{http://wiki.ros.org/gmapping}{gmapping}, which is a popular ROS package, used in a wide variety of applications that require map-building and localization. Its SLAM algorithm takes LIDAR measurements as its input and generates an occupancy grid (a 2D map) of the car's environment. By using this map it is able to correct the car's (usually inaccurate odometry-based) position and orientation. I tried out the package, and the result maps were promising, the generated map was insensitive to the car's longitudinal movements and its rotations. But unfortunately, gmapping's SLAM does not support dynamic objects. The algorithm does not recognize changes in the environment, therefore if an object has been detected and placed in its map, it will not be erased from there, even after the objects has moved away. Figures \ref{gmapping_drawback_before_move} and \ref{gmapping_drawback_after_move} demonstrate the problem.

\begin{figure}[!ht]
\centering
\subfloat[Gazebo simulation]
{
    \includegraphics[height=48mm]{figures/raw/gazebo_gmapping_before_move2.png}
    \label{gazebo_gmapping_before_move}
}
\subfloat[Map created by gmapping]
{
\includegraphics[height=48mm]{figures/raw/rviz_gmapping_before_move2.png}
    \label{rviz_gmapping_before_move}
}
\caption{Initial state - ball is still}
\label{gmapping_drawback_before_move}
\end{figure}

Figure \ref{gmapping_drawback_before_move} shows a situation where the ball is standing still. A the mapping algorithm of gmapping successfully creates a map (in the form of an occupancy grid\footnote{An occupancy grid represents a map in an evenly spaced field of probability values representing if the grid points are occupied by an obstacle}) that marks the place of the ball as occupied. However, when the ball starts moving (see figure \ref{gmapping_drawback_after_move}), the map does not change, because the algorithm cannot handle moving obstacles.

\begin{figure}[!ht]
\centering
\subfloat[Gazebo simulation]
{
    \includegraphics[height=48mm]{figures/raw/gazebo_gmapping_after_move2.png}
    \label{gazebo_gmapping_after_move}
}
\subfloat[Map created by gmapping]
{
    \includegraphics[height=48mm]{figures/raw/rviz_gmapping_after_move2.png}
    \label{rviz_gmapping_after_move}
}
\caption{Moving state - ball has changed position}
\label{gmapping_drawback_after_move}
\end{figure}

As a conclusion, in this project, gmapping could not be used as the producer of the static map. But that didn't mean it couln't be used for its second feature, localization. Note, that the mapping implementation I made is not a SLAM algorithm, it is not able to make corrections to the car's pose. So for that purpose, I still needed the help of gmapping, which proved to be very reliable at localization.

In order to create two disjunct maps, one static and one dynamic, the key element of the process is the separation of the moving and non-moving obstacles of the measured points. After determining these two disjunct set of points, the maps can be converted to any desired or required format. Static maps are usually published as occupancy grids, while dynamic obstacles need to present information about their speed vector. Occupancy grids do not group the grid points according to their probabilities, therefore they do not know about the obstacles' borders and areas\footnote{In this project, 2D LIDARs were used, therefore the measured objects were seen as 2D shapes that have areas, not 3D objects that have volumes}. Dynamic obstacles however can be either represented as separate points with their own speed vectors, or groups of points, each groups having one speed vector. I chose the latter representation, thus publishing groups that contain a set of points (all the points, ideally) of the same obstacle. This way there is a one-to-one relationship between moving obstacles and groups. The separation and grouping methods of the mapping process is shown on diagram \ref{mapping_method}.

\tikzset{
     base_node/.style = {rectangle, rounded corners, draw=black,
                         minimum width=5cm, minimum height=1cm,
                         text centered, font=\sffamily},
  inout_node/.style   = {base_node, fill=blue!30},
  common_node/.style  = {base_node, fill=orange!15},
  dynamic_node/.style = {base_node, fill=green!30},
  static_node/.style  = {base_node, fill=red!30},
  decoration={brace},
  tuborg/.style={decorate},
  tubnode_left/.style={midway, left=2pt},
  tubnode_right/.style={midway, right=2pt}
}

\begin{figure}[!ht]
    \begin{tikzpicture}[
            node distance=1.5cm,
            every node/.style={fill=white, font=\sffamily}, align=center]
        % Node descriptions
        \node (scan)            [inout_node]                                   {Input scan};
        \node (convert_abs)     [common_node, below of=scan]                   {Convert to absolute points};
        \node (sub_image)       [common_node, below of=convert_abs]            {Create subtraction image};
        \node (dynamic_points)  [common_node, below of=sub_image]              {Find dynamic points};
        \node (groups)          [common_node, below of=dynamic_points]         {Make dynamic groups};
        \node (separate)        [common_node, below of=groups]                 {Separate static points from groups};
        % Dynamic nodes
        \node (speed_vectors)   [dynamic_node, below of=separate, xshift=-3cm] {Calculate speed vectors};
        \node (areas)           [dynamic_node, below of=speed_vectors]         {Calculate and validate areas};
        \node (publish_dynamic) [inout_node, below of=areas]                   {Publish dynamic obstacles};
        % Static nodes
        \node (update_map)      [static_node, below of=separate, xshift=3cm]   {Update static map};
        \node (convert_scan)    [static_node, below of=update_map]             {Remap to LIDAR scan};
        \node (publish_static)  [inout_node, below of=convert_scan]            {Publish static scan};
        % Connections
        \draw[->]           (scan) -- (convert_abs);
        \draw[->]    (convert_abs) -- (sub_image);
        \draw[->]      (sub_image) -- (dynamic_points);
        \draw[->] (dynamic_points) -- (groups);
        \draw[->]         (groups) -- (separate);
        % Dynamic connections
        \draw[->]       (separate) -- (speed_vectors);
        \draw[->]  (speed_vectors) -- (areas);
        \draw[->]          (areas) -- (publish_dynamic);
        % Static connections
        \draw[->]       (separate) -- (update_map);
        \draw[->]     (update_map) -- (convert_scan);
        \draw[->]   (convert_scan) -- (publish_static);
        % Decorations
        \draw[tuborg, decoration={brace}] let \p1=(scan.north), \p2=(separate.south) in
            ($(\x1+3.4cm, \y1)$) -- ($(\x1+3.4cm, \y2)$) node[tubnode_right] {Separation + grouping};
        \draw[tuborg, decoration={brace}] let \p1=(speed_vectors.north), \p2=(publish_dynamic.south) in
            ($(\x1-3cm, \y2)$) -- ($(\x1-3cm, \y1)$) node[tubnode_left] {Dynamic};
        \draw[tuborg, decoration={brace}] let \p1=(update_map.north), \p2=(publish_static.south) in
            ($(\x1+3cm, \y1)$) -- ($(\x1+3cm, \y2)$) node[tubnode_right] {Static};
    \end{tikzpicture}
    \caption{Mapping method}
    \label{mapping_method}
\end{figure}

The diagram consists of 3 subgraphs - these are also marked on the diagram. The first, and most important is the separation and grouping of dynamic points. The second section describes the additional calculations that need to be done for the dynamic obstacles, and consists the documentation for the message structure definining these dynamic obstacles. The third section is about the static map that is built from the static points. The next sections are going to explain these subgraphs in detail.

\section{Separation and grouping}
This section describes the method of separating dynamic and static points of the input scan. This step is essential in the pipeline of creating two disjunct maps.

\subsection{Input scan}


\subsection{Absolute points}


\subsection{Subtraction image}


\subsection{Dynamic points}


\subsection{Dynamic groups}


\subsection{Separation of static points and dynamic groups}


\section{Dynamic obstacles}
After the dynamic groups have been separated from the static points, additional information needs to be calculated for them, so that the local track planner algorithm can use their data for its obstacle-avoidance feature.

\subsection{Speed vectors}


\subsection{Area validation}


\subsection{Publishing dynamic obstacles}


\section{Static points}
Static points used for two separate purposes. The first one is building a static map, the second is localization with the help of gmapping.

\subsection{Static map}


\subsection{Remapping to LIDAR scan}


\subsection{Publishing static scan}
